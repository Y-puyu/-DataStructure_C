#include <stdio.h>	
#include <iostream>	
#include <stdlib.h>
#include <assert.h>
#define MAX_LEN	(100)
using namespace std;

typedef int QDataType;

typedef struct {
	QDataType data[MAX_LEN];
	int front;
	int rear;
}   SQueue;

// 初始化队列
void InitSQueue(SQueue *q) {
	q->front = q->rear = -1;
}

// 入队
void SQueuePush(SQueue *q, int val) {
	q->rear++;
	q->data[q->rear] = val;
}

// 出队
void SQueuePop(SQueue *q){
	q->front++;
}
void SQueuePrint(SQueue *q) {
	for (int i = 0; i < q->rear; i++) {
		cout << q->data[i] << "  " << endl;
	}

}


typedef int QDataType;
// 用单链表实现队列
// 链表的结点
typedef struct QNode {
	QDataType val;
	struct QNode *next;
}	QNode;

// 队列
typedef struct Queue {
	QNode *front;	// 指向链表的第一个结点，如果链表为空， == NULL
	QNode *rear;	// 指向链表的最后一个结点，如果链表为空， == NULL
}	Queue;

// 初始化/销毁
void QueueInit(Queue *queue) {
	queue->front = queue->rear = NULL;
}

// 入队
void QueuePush(Queue *queue, QDataType val) {
	// 申请结点
	QNode *node = (QNode *)malloc(sizeof(QNode));
	assert(node);
	node->val = val;
	node->next = NULL;
	
	if (queue->rear == NULL) {
		queue->front = queue->rear = node;
	}
	else {
		queue->rear->next = node;
		queue->rear = node;
	}
}

// 出队
void QueuePop(Queue *queue) {
	assert(queue != NULL);
	QNode *old_front = queue->front;
	queue->front = queue->front->next;
	free(old_front);

	if (queue->front == NULL) {
		queue->rear = NULL;
	}
}

// 打印队列元素        
void QueuePrint(Queue *queue) {
	Queue *qtmp = queue;
	for (QNode *q = qtmp->front; q != queue->rear; q=q->next) {
		cout << qtmp->front->val << ' ';
		// qtmp->front = qtmp->front->next;   出了bug 搞了1天....
	}
	cout << queue->rear->val<<endl;
}

// 数据类型
typedef int SDataType;

// 利用静态顺序表实现栈
typedef struct {
	SDataType	array[MAX_LEN];
	int			top;	// 职责就是原来的 size
}	Stack;

// 初始化栈
void StackInit(Stack *stack) {
	stack->top = 0;
}

// 入栈 只能从栈顶插入
void StackPush(Stack *stack, SDataType val) {
	assert(stack);
	assert(stack->top < MAX_LEN);

	stack->array[stack->top] = val;
	stack->top++;
}

// 出栈 只能从栈顶删除
void StackPop(Stack *stack) {
	assert(stack);
	assert(stack->top > 0);

	stack->top--;
}

// 打印栈元素
void StackPrint(Stack *stack) {
	assert(stack);
	for (int i = 0; i < stack->top; i++) {
		cout << stack->array[i] << "  ";
	}
	cout << endl;
}

// 菜单
void menu() {
	cout << "**************************************" << endl;
	cout << "a. 初始化栈" << endl;
	cout << "b. 入栈" << endl;
	cout << "c. 出栈" << endl;
	cout << "d. 打印栈内元素" << endl;
	cout << "e. " << endl;
	cout << "f. " << endl;
	cout << "g. " << endl;
	cout << "h. " << endl;
	cout << "i. " << endl;
	cout << "g. " << endl;
	cout << "h. " << endl;
	cout << "k. " << endl;
	cout << "m. 初始化链式队列" << endl;
	cout << "n. 数据元素val_4入队，请输入整形数字val:" << endl;
	cout << "o. 队尾元素出队：" << endl;
	cout << "p. 打印链式队列元素" << endl;
	cout << "**************************************" << endl;
}

int main() {
	char x;
	Stack stack;
	Queue queue;
	SQueue squeue;
	menu();
	while (cin >> x) {
		switch (x) {
		// 顺序式栈
		case 'a':
			cout << "初始化栈stack,初始化成功！"<< endl;
			StackInit(&stack);
			menu();
			break;
		case 'b':
			cout << "数据元素val_1入栈，请输入整形数字val_1:";
			SDataType val_1;
			cin >> val_1;
			StackPush(&stack, val_1);
			cout << "入栈成功" << endl;
			menu();
			break;
		case 'c':
			cout << "栈顶元素出栈：" << endl;
			StackPop(&stack);
			cout << "出栈成功！" << endl;
			menu();
			break;
		case 'd':
			cout << " 打印栈内元素： ";
			StackPrint(&stack);
			menu();
			break;
		
		// 链式栈
		case 'e':

			break;

		case 'f':
			break;

		case 'g':
			break;
		case 'h':
			break;

		// 顺序队列
		case 'i':
			cout << "初始化顺序式队列" << endl;
			InitSQueue(&squeue);
			cout << "顺序式队列初始化成功" << endl;
			break;

		case 'j':
			QDataType val_3;
			cout << "数据元素val_3入队，请输入整形数字val:";
			cin >> val_3;
			cout << endl;
			SQueuePush(&squeue, val_3);
			menu();
			break;

		case 'k':
			cout << "队尾元素出队" << endl;
			SQueuePop(&squeue);
			cout << "出队成功" << endl;
			menu();
			break;
		case 'l':
			cout << "打印顺序式队列元素" << endl;
			SQueuePrint(&squeue);
			menu();
			break;
		

		// 链式队列
		case 'm':
			cout << "初始化链式队列" << endl;
			QueueInit(&queue);
			cout << "链式队列初始化成功" << endl;
			menu();
			break;

		case 'n':
			QDataType val_4;
			cout << "数据元素val_4入队，请输入整形数字val:";
			cin >> val_4;
			cout << endl;
			QueuePush(&queue, val_4);
			menu();
			break;


		case 'o':
			cout << "队尾元素出队：" << endl;
			QueuePop(&queue);
			cout << "出队成功" << endl;
			menu();
			break;
		case 'p':
			cout << "打印链式队列元素" << endl;
			QueuePrint(&queue);
			menu();
			break;
		}
	}
	system("pause");
	return 0;
}